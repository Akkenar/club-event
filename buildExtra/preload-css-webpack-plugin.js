const debug = require('debug')('PreloadChunks');

const MODULE_NAME = 'preload-css-webpack-plugin';

/**
 * Get an object that contains the `as` and `href` to be
 * used in the HTML template to generate the `<link ref="preload">`.
 *
 * @param {String} publicPath - The href public path
 * @return {function(*)} - A function that return an object based on the file name
 */
const getPreloadTag = publicPath => filename => ({
  href: `${publicPath || ''}${filename}`,
  // For now prefetch everything, rather than preloading. It yields better results
  // with Lighthouse. We might want to tune this depending on whether the chunk is
  // considered critical.
  rel: 'prefetch',
  filename,
});

/**
 * Aggregate preload object from all the `files` in the `chunk`.
 *
 * @param {String} publicPath - The Webpack public path to prepend to the file name
 * @return {function(Array, Object)} - A function accepting an accumulator and a current
 * `chunk` to be used in `reduce`
 */
const aggregatePreloadTag = publicPath => (files, chunk) => {
  const filesToPreload = chunk.files.map(getPreloadTag(publicPath));
  return [...files, ...filesToPreload];
};

/**
 * Exclude chunks that are initial, as we don't want to load them two times.
 * @param chunk
 * @return {boolean}
 */
const excludeCriticalChunks = chunk => {
  const { name } = chunk;
  return name !== 'bundle';
};

/**
 * Add the structure to preload CSS for critical chunks.
 * To be used in a template, such as an *.ejs template and with Webpack HTML plugin.
 */
class PreloadCssChunks {
  apply(compiler) {
    compiler.hooks.compilation.tap(MODULE_NAME, compilation => {
      // Executed while the Webpack HTML plugin generates the HTML fragment.
      compilation.hooks.htmlWebpackPluginBeforeHtmlGeneration.tapAsync(
        MODULE_NAME,
        (htmlPluginData, callback) => {
          // From the Webpack output object.
          const { publicPath } = compiler.options.output;

          // All the chunks generated by the Webpack compilation, after all other plugin magics.
          const chunksToPreload = compilation.chunks
            .filter(excludeCriticalChunks)
            // Create the object to be used in the template
            .reduce(aggregatePreloadTag(publicPath), [])
            // Only CSS
            .filter(chunk => chunk.filename.match(/(.*)\.css$/));

          debug(`Chunk files to preload: ${JSON.stringify(chunksToPreload)}`);

          // Mutates the Webpack HTML plugin data, as recommended by this plugin.
          // eslint-disable-next-line no-param-reassign
          htmlPluginData.assets.preloadChunks = chunksToPreload;

          // As per documentation, invoke the callback without error and with the mutated
          // Webpack HTML plugin data
          callback(null, htmlPluginData);
        }
      );
    });
  }
}

module.exports = PreloadCssChunks;
