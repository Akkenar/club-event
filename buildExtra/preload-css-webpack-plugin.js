const debug = require('debug')('PreloadChunks');

const MODULE_NAME = 'preload-css-webpack-plugin';

/**
 * Get an object that contains the `as` and `href` to be
 * used in the HTML template to generate the `<link ref="preload">`.
 *
 * @param {String} publicPath - The href public path
 * @return {function(*)} - A function that return an object based on the file name
 */
const getPreloadTag = publicPath => filename => ({
  href: `${publicPath || ''}${filename}`,
  rel: 'preload',
  filename,
});

/**
 * Aggregate preload object from all the `files` in the `chunk`.
 *
 * @param {String} publicPath - The Webpack public path to prepend to the file name
 * @return {function(Array, Object)} - A function accepting an accumulator and a current
 * `chunk` to be used in `reduce`
 */
const aggregatePreloadTag = publicPath => (files, chunk) => {
  const filesToPreload = chunk.files.map(getPreloadTag(publicPath));
  return [...files, ...filesToPreload];
};

/**
 * Exclude chunks that are initial, as we don't want to load them two times.
 * @param chunk
 * @return {boolean}
 */
const excludeCriticalChunks = chunk => {
  const { name } = chunk;
  return name !== 'bundle';
};

/**
 * Filter on chunks that match at least one of the chunk name.
 * @param chunkNames
 * @return {function(*): *}
 */
const filterOnChunks = chunkNames => chunk => {
  const { name } = chunk;
  return chunkNames.some(chunkName => {
    // Matches 'name' or 'vendors~name' or 'vendors~name~foo'. Assumes that the vendor
    // chunks follow the default naming pattern.
    const matchNameOrVendorName = new RegExp(`~?(${chunkName})($|~)`, 'gm');
    return name.match(matchNameOrVendorName);
  });
};

/**
 * Add the structure to preload CSS for critical chunks.
 * To be used in a template, such as an *.ejs template and with Webpack HTML plugin.
 */
class PreloadCssChunks {
  constructor({ chunkNames }) {
    debug(`Chunks to preload: ${JSON.stringify(chunkNames)}`);
    this.chunkNames = chunkNames || [];
  }

  apply(compiler) {
    compiler.hooks.compilation.tap(MODULE_NAME, compilation => {
      // Executed while the Webpack HTML plugin generates the HTML fragment.
      compilation.hooks.htmlWebpackPluginBeforeHtmlGeneration.tapAsync(
        MODULE_NAME,
        (htmlPluginData, callback) => {
          // From the Webpack output object.
          const { publicPath } = compiler.options.output;

          // All the chunks generated by the Webpack compilation, after all other plugin magics.
          const chunksToPreload = compilation.chunks
            .filter(excludeCriticalChunks)
            .filter(filterOnChunks(this.chunkNames))
            // Create the object to be used in the template
            .reduce(aggregatePreloadTag(publicPath), [])
            // Only CSS
            .filter(chunk => chunk.filename.match(/(.*)\.css$/));

          debug(`Chunk files to preload: ${JSON.stringify(chunksToPreload)}`);

          // Mutates the Webpack HTML plugin data, as recommended by this plugin.
          // eslint-disable-next-line no-param-reassign
          htmlPluginData.assets.preloadChunks = chunksToPreload;

          // As per documentation, invoke the callback without error and with the mutated
          // Webpack HTML plugin data
          callback(null, htmlPluginData);
        }
      );
    });
  }
}

module.exports = PreloadCssChunks;
